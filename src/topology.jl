## Topology objects

# Base composite type describing a topology
type Topology
    dim     ::Integer             # Number of active dimensions (e.g., 1D, 2D, etc.)
    coords  ::Array{Float64}      # N x ndim matrix containing the coordinates of the system
    bonds   ::Set{Tuple}          # Set of tuples. Each tuple describes a bond between two atoms
    dist_mat::Array{Int64,2}      # Distance matrix. Each entry is the distance between two sites
    # NOTE: even though I believe the boundary conditions should be a property of the Hamiltonian object,
    #       it's much easier to have them here, such that the distance matrix can be populated accordingly.
    #       Morevoer, in this way I avoid to have an if statement in every hamiltonian constructor that
    #       checks which topology I have and add the bc accordingly. In summary, this is more extensible.
    bc      ::AbstractString      # Boundary conditions
end

# Generate the topology of a one dimensional lattice
# NOTE: the origin is at the centre of the lattice
function lattice_generator(L::Integer, lat_const::Real = 1.0, bc::ASCIIString = "obc")
    coords = collect(linspace(-(L-1)*lat_const/2,(L-1)*lat_const/2,L))  # Generate coordinates of the lattice
    bonds = Set{Tuple}()                # Initialize bonds NOTE: deprecated, soon to be erased
    dist_mat = ones(L,L)*(2*L)          # Initialize distance matrix: all entries are 2*L

    # Setting nearest neighbors
    for i = 1:L-1
        push!(bonds,(i,i+1))
        push!(bonds,(i+1,i))
        dist_mat[i,i+1] = 1
        dist_mat[i+1,i] = 1
        dist_mat[i,i]   = 0
    end
    dist_mat[L,L] = 0

    # Check boundary conditions
    if bc == "pbc"
        dist_mat[1,L] = 1
        dist_mat[L,1] = 1
    end

    # Compute all the distances between the sites
    populate_dist_mat!(dist_mat)

    return Topology(1, coords, bonds, dist_mat, bc)
end

# Generate the topology of a regular polygon
# NOTE: the polygon is centered in the origin of the xy-plane
function polygon_generator(L::Integer, bond_length::Real = 1.0)
    ## Construct geometry
    radius = 1 / (2*sin(pi/L))          # Radius of the outer circumference surrounding the polygon
    coords = zeros(L,2)                 # Initialize coords matrix, just 2 dimensions
    # Wrap the linear coordinates and put them on a circle
    coords[:,1] = radius * cos((2*pi/L)*collect(0:(L-1)))
    coords[:,2] = radius * sin((2*pi/L)*collect(0:(L-1)))

    # Setting nearest neighbors
    dist_mat = ones(L,L)*(2*L)          # Initiliaze distance matrix
    bonds = Set{Tuple}()                # Initialize bonds
    for i = 1:L-1                       # Push bonds into list and set 0 and 1 distances
        push!(bonds,(i,i+1))
        push!(bonds,(i+1,i))
        dist_mat[i,i+1] = 1
        dist_mat[i+1,i] = 1
        dist_mat[i,i]   = 0
    end
    dist_mat[L,L] = 0
    dist_mat[1,L] = 1; dist_mat[L,1] = 1

    # Populate all the distances between the sites
    populate_dist_mat!(dist_mat)

    return Topology(2, coords, bonds, dist_mat, "obc")
end

# Generate the topology of a graphene ribbon
# NOTE: for the time being, the graphene nanoribbon is
#       generated by stacking polyene chains on top of
#       each other. This might not be the best solution
# Stacking polyene chains (\/\/\/\/\/\) on top of each other
# NOTE: the ribbon is NOT centered at the xy origin
function graphene_generator(L::Integer, C::Integer, CC_bond::Float64 = 1.0, bc::ASCIIString = "obc")
    if L < 4
        throw(ArgumentError("L has to be at least 4"))
    elseif C < 2
        throw(ArgumentError("C has to be at least 2"))
    elseif L%2 == 1
        throw(ArgumentError("L has to be even"))
    elseif bc != "obc"
        throw(ArgumentError("Currently only obc are supported"))
    end

    xproj  = CC_bond * cos(pi/6)            # Projection of carbon atom on x-axis
    yproj  = CC_bond * cos(pi/3)            # Projection of carbon atom on y-axis

    coords      = zeros(L*C, 2)             # Initialize matrix for coords, only 2 dimensions
    coords[:,1] = repmat(collect(0:xproj:xproj*(L-1)), C, 1)        # Putting x coordinates

    ytmp0 = repmat([yproj;0], round(Int, L/2), 1)                   # Temporary y coords. of C atoms
    ytmp1 = repmat([yproj+CC_bond;2*CC_bond], round(Int, L/2), 1)   # Two differet y coords for each polyene chain

    # Looping over the number of polyene chains to be stacked on top of each other
    for j = 1:C       # NOTE: should add polyene chains one by one, is it a problem?
        if j%2 == 1
            coords[(j-1)*L+1:j*L,2] = ytmp0+(j-1)*3/2*CC_bond       # One of the two heights of C atoms
        elseif j%2 == 0
            coords[(j-1)*L+1:j*L,2] = ytmp1+(j-2)*3/2*CC_bond       # The second height
        end
    end

    ## Construct connections
    dist_mat = ones(L*C,L*C)*(2*L*C)        # Initiliaze distance matrix
    bonds = Set{Tuple}()                    # Initialize bonds
    for i = 1:L*C
        dist_mat[i,i] = 0
    end
    for j = 1:C
        for i = 1:L
            if i < L
                push!(bonds,(i+(j-1)*L,i+1+(j-1)*L))
                push!(bonds,(i+1+(j-1)*L,i+(j-1)*L))
                dist_mat[i+(j-1)*L,i+1+(j-1)*L] = 1
                dist_mat[i+1+(j-1)*L,i+(j-1)*L] = 1
            end
            if j%2 == 1 && i%2 == 1 && i < L && j < C
                push!(bonds,(i+(j-1)*L,(i+j*L)%(L*C)))
                push!(bonds,((i+j*L)%(L*C),i+(j-1)*L))
                dist_mat[i+(j-1)*L,(i+j*L)%(L*C)] = 1
                dist_mat[(i+j*L)%(L*C),i+(j-1)*L] = 1
            elseif j%2 == 0 && i%2 == 0 && j < C
                push!(bonds,(i+(j-1)*L,(i+j*L)))
                push!(bonds,((i+j*L),i+(j-1)*L))
                dist_mat[i+(j-1)*L,(i+j*L)] = 1
                dist_mat[(i+j*L),i+(j-1)*L] = 1
            end
        end
    end

    # Compute all the distances between atoms
    populate_dist_mat!(dist_mat)

    return Topology(2, coords, bonds, dist_mat, bc)
end

# Generate the topology of an (n,m) carbon nanotube of length l
# NOTE: The nanotube is centered along the z-axis
function nanotube_generator(n::Integer, m::Integer , l::Integer, CC_bond::Float64 = 1.0, bc::ASCIIString = "obc")
    if n < m || n+m < 6
        throw(ArgumentError("n + m must be at least 6, with n >= m"))
    elseif bc != "obc"
        throw(ArgumentError("Currently only obc are supported"))
    end

    if n == m
        L = (l+1)*2     # Polyene chain length
        C = n+m+2       # Number of polyene chains
    elseif m == 0
        L = n*2
        C = l+1
    else
        throw(ErrorException("Chiral nanotubes are not supported yet!"))
    end

    graphene = graphene_generator(L, C, CC_bond)    # Generate a graphene nanoribbon
    bonds    = graphene.bonds                       # Inherit the bonds
    dist_mat = graphene.dist_mat                    # Inherit the distance matrix
    coords   = zeros(L*C, 3)                        # This is required to avoid a scope error

    if n == m           # Armchair nanotube
        z   = graphene.coords[:,1]              # The x-axis of the graphene ribbon becomes the z-axis
        xgr = graphene.coords[:,2]              # While the y-axis becomes the x-axis which will be wrapped

        # Compute the radius of the nanotube
        sinfac = (maximum(xgr)+CC_bond)/(2*pi)  # Sinusoidal factor
		alpha  = CC_bond/sinfac                 # Angle
		radius = (CC_bond/2)/(sin(alpha/2))     # Radius of the nanotube

        # Roll x- and y-axis of the graphene ribbon
        x = radius * cos(1/sinfac * xgr)
        y = radius * sin(1/sinfac * xgr)

        # Shift the nanotube such that is centered along the z-axis
		zshift = abs(maximum(z)-minimum(z))/2
		z = z - zshift

        # Connect the edges of the ribbon by adding the bonds to the list and modifying the distance matrix
        for i = 1:L
            if i%2 == 0
                push!(bonds,(i,i+(C-1)*L))
                push!(bonds,(i+(C-1)*L,i))
                dist_mat[i,i+(C-1)*L] = 1
                dist_mat[i+(C-1)*L,i] = 1
            end
        end
        populate_dist_mat!(dist_mat)               # Update distance matrix
        coords = [x y z]                           # Bind coordinates in a single matrix
    elseif m == 0       # Zig zag nanotube
        xgr = graphene.coords[:,1]                 # The x-axis of the graphene ribbon which will be wrapped
        z   = graphene.coords[:,2]                 # The y-axis of the graphene ribbon becomes the z-axis

        # Compute the radius of the nanotube
		xproj_CC_bond = abs(xgr[2] - xgr[1])            # Carbon-carbon bond length projected onto the x-axis
        sinfac = (maximum(xgr)+ xproj_CC_bond)/(2*pi)   # Sinusoidal factor
		radius = (xproj_CC_bond/2)/(sin(pi/L))          # Radius of the nanotube

        # Roll x- and y-axis of the graphene ribbon
        x = radius * cos(1/sinfac * xgr)
        y = radius * sin(1/sinfac * xgr)

        # Shift the nanotube such that is centered along the z-axis
		zshift = abs(maximum(z)-minimum(z))/2
		z = z - zshift

        # Connect the edges of the ribbon by adding the bonds to the list and modifying the distance matrix
        for j = 1:C
                push!(bonds,(1+(j-1)*L,j*L))
                push!(bonds,(j*L,1+(j-1)*L))
                dist_mat[1+(j-1)*L,j*L] = 1
                dist_mat[j*L,1+(j-1)*L] = 1
        end
        populate_dist_mat!(dist_mat)             # Update distance matrix
        coords = [x y z]                         # Bind coordinates in a single matrix
    else
        throw(ErrorException("I don't know how you got here!"))
    end

    return Topology(3, coords, bonds, dist_mat, bc)
end

# Populate the distance matrix
# Input: a matrix with zeros on the diagonal and ones on connected
# sites. All the other entries are much larger.
# Ouput: the populated matrix with the distance between each site
# NOTE: naive algorithm, O(N^3 + logN)
function populate_dist_mat!(D)
    L = size(D,1)
    Dold = deepcopy(D)
    for iter = 1:L
        for i = 1:L
            for j = i+1:L
                D[i,j] = D[j,i] = min(D[i,j],minimum(D[i,:]'+D[:,j]))
            end
        end
        if norm(Dold-D) == 0
            return
        end
        Dold = deepcopy(D)
    end
end

# Generate the topology of a lattice of arbitrary dimension
#=
function lattice_generator(nsites::Array{Integer,1}, lat_consts::Array{Real,1}, bc::String = "obc")
    ndim = length(nsites)       # Number of dimensions
    if ndim != length(lat_consts)
        throw(DimensionMismatch("the arguments nsites and lat_consts have to be one-dimensional arrays of the same length"))
    end
    coords = zeros(nsites,ndim)
    for i = 1:ndim
        coords[:,i] = collect(linspace(-(nsites[i]-1)*lat_consts[i]/2,(nsites[i]-1)*lat_consts[i]/2,nsites[i]))
    end
    bonds = Set{Tuple}()
    for i = 1:ndim
        for j = 1:nsites[i]-1
            push!(bonds,(j + (i-1)*nsites[i]   ,j+1))
        push!(bonds,(i+1,i))
    end
    if pbc
        push!(bonds,(1,N))
        push!(bonds,(N,1))
    end

    # Generate Topology
    ret = Topology(xyz, 1, bonds)
    return ret
end

# Generate the topology of a polyene chain of length nsites
function polyene_generator(nsites, bond_ratio, two_bond_length, pbc)
    ## Construct geometry
    xyz = zeros(nsites,3)
    long_bond = bond_ratio * two_bond_length / (1 + bond_ratio)         # Find the length of the longer bond
    short_bond = two_bond_length - long_bond                            # Find the length of the shroter bond
    xproj = two_bond_length / 2 * cos(pi/6)                             # Projection onto the x-axis of the the second atom
    xtmp = zeros(nsites+1)                                              # Temporary variable
    xtmp[1:2:nsites+1] = 0:2*xproj:(nsites+1)*xproj                     # Fill in with all the x's lying on y=0, one element more
                                                                        # is needed to place correctly the last element
    xyz[1:2:nsites,1] = xtmp[1:2:nsites]                                # Copy over to output, leaving out last element
    for i = 2:2:nsites                  # Find the coordinates for x and y, solving the system of eq. of two circles, bond angle is free
        x = -1/2 * (long_bond^2 - short_bond^2 + xtmp[i-1]^2 - xtmp[i+1]^2) / (xtmp[i+1] - xtmp[i-1])
        y = sqrt(short_bond^2 - x^2 - xtmp[i-1]^2 + 2*x*xtmp[i-1])
        xyz[i,1] = x
        xyz[i,2] = y
    end
    xyz[:,2] = flipdim(xyz[:,2],1) - abs(maximum(xyz[:,2])-minimum(xyz[:,2]))/2                                 # Flip elements such that first bond goes downward (convention)
    xyz[:,1] = xyz[:,1] - xproj*(nsites-1)/2                    # Shift molecules, such that origin is in the middle of the chain

    ## Construct connections
    bonds = Array(Tuple,0)
    for i = 1:nsites-1                                          # Push bonds into list, no PBC in this case
        push!(bonds,(i,i+1))
        push!(bonds,(i+1,i))
    end
    if pbc
        push!(bonds,(1,nsites))
        push!(bonds,(nsites,1))
    end

    ## Generate Topology
    ret = Topology(xyz, 2, bonds)
    return ret
end
=#
